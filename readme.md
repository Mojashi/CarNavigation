## 実行方法
１．g++ source.cpp -O3 -o main
２．python3 makecase.py NET （テストケースの生成　事前にcaseディレクトリを作成しておく必要あり）
３．python3 batch.py ./main case　（./mainは実行ファイルの名前 caseはテストケースのディレクトリを指す）

でMINDIST、GA、GA+GREEDYそれぞれでNrate=5~40まで５刻みで実行（論文での一つ目のケース）し、最後に結果をまとめて表示

その他いろいろな定数はrun.py内の変数を変更して設定してください。単位はすべて長さはm、時間はsecondです。（出力は論文にそろえてkm/hになってます）

## 実装を読む上での注意
・辺の順位付けは論文だと1からだったか0からに変更


## 不明だったためこちらで決めたこと
### 突然変異
・どうランダム変更するかが明記されていない。（各頂点には上限があるのでそんなに自由には変更できない）
	ルートの前から順に見ていって各頂点で接続されている辺の数以下でランダムな整数を求めた。またこの時、変更して点以降のルートで接続されている辺の数を超過する可能性があるのでそのような遺伝子があれば許される最大値に修正。また、新規にルートを作成する必要がある場合、0で初期化する（この後突然変異の判定をする）。

### 最短経路化
・ルート変更による新規ルート作成などの扱い
	突然変異とおなじ


## 今回の手法
論文の手法に加えて毎回の遺伝的アルゴリズムの実行後に独自の近傍の定義をした山登り法を行い改善した。

各車両が最短経路以外を通る必要があるのは渋滞を回避するためであるが、論文の手法では渋滞の回避に相当する解の操作が存在していない。そこで、渋滞の回避を目的として経路の連続した一部を別のルートに取り替える操作を近傍としてGA実行後に山登り法を行うことで解の改善を行う。（GAの中で当該の操作を取り入れる方法も実験したのですが、論文の手法と同程度の結果しか出ませんでした。テストケースの性質的にすでに最適解付近の解が出てしまっているのかもしれません。別のグラフなどで試せば優位性が確認できるかもしれないです。）

山登り法で用いることを考えた時に、近傍のサイズが大きくなりすぎると計算量が非常に大きくなってしまうので、せめて近傍のサイズとしてグラフサイズと経路長に対して多項式時間であることが条件である。

### 近傍
ある車の通る経路Tをその経路が通過する頂点を順番に並べたものとする。T = (A,B,C,D,E)だとグラフの頂点をA->B->C->D->Eとたどっていく。（インデックスがふられていると考えてください。）
ある整数i < |T|を取り、頂点T[i]以降の一部を別のルートと取り替える。
渋滞を迂回するという目的であるから、別ルートと取り替えた結果T[i]の次の頂点が変更前と同じであることは避ける。
- T[i]の次にすぐにT[i+1]がこない
- Uターンを許さない(A->B->A)
という条件のもと、T[i]から頂点Qへの最短経路をdist'(T[i],Q)とする。
min_{j > i} dist'(T[i],T[j]) で最小値を達成するjをmとし、T[i]からT[m]をその間をつなぐ最短経路で取り替える。

ある解Sの近傍の数は車両の数をNcar、解の中の最長経路長をLmaxとしてθ(Ncar*Lmax)個であり十分に少ない。

### 山登り法
すべての車両、すべての経路中の点について上記の操作を行い解が改善するかどうかチェックする。ここで評価関数は論文のものと同様にTpred経過した後と元の状態を比較しどれだけ平均して速度が出ていたかを用いる。実装上は２重forループで外側のループで車両、内側のループで経路の頂点を前から走査しており、この走査順をランダム順にかえるなど工夫することで解が改善する余地がある。

### 実験
